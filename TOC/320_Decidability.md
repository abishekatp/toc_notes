
## Computability Theory(Decidability)

### A_DFA is decidable

* Here we have to decide whether DFA accepts a particular string w using some Turing machine.
* This is called an acceptance problem of DFA. To prove this we can construct a deterministic TM D_A_DFA which will simulate the DFA internally on input string w and accept if DFA accepts.


### A_NFA is decidable 



* Here we have to decide whether NFA accepts a particular string w using some Turing machine.
* Acceptance problem of NFA. convert a NFA to an equivalent DFA then use TM D_A_DFA to decide whether NFA accepts w or not. If it accepts then accept. Note that here we are reducing the problem A_NFA to the problem A_DFA to solve it using A_DFA.


### E_DFA is decidable 



* Here we have to decide whether DFA recognises empty language. That means no string is accepted by that particular DFA.
* To prove this mark the start state and mark all the states that can be reached from already marked states. Do this until no new state is marked. At the end If no accept state is marked then DFA accepts empty language.
* The other approach can be testing all the strings of length up-to the number of states. If none of them are accepted then reject . So if some string longer than the number of states is accepted then there must be some repetition in computational configuration. So we can remove that repetition to get the shorter accepting string. This way deciding all the strings of length less than or equal to the number of states will be enough to validate the empty DFA language.


### EQ_DFA is decidable



* checking whether two DFA’s are equal is decidable. One way to prove this could be by checking all the strings of up-to the length equal to the number of states, then if any one string acts differently on two DFAs then they are not equal. This is similar to E_DFA logic.
* The other way is to create DFA C that will accept w if DFA A and DFA B disagree on input w. Here disagree means for some input w A will accept and B will reject or vice versa could happen. Now we can use E_DFA to test whether DFA C accepts empty language if yes then A and B are equal.


### A_ CFG is decidable



* Deciding whether a string is generated by CFG or not. To prove this we need to convert CFG G to Chomsky Normal Form(CNF) which we call CFG_CNF_G. Which allows only two types of derivations A->BC or B->b. Then we will use the constraint of CNF and generate all possible strings with exactly (2|w| - 1) steps. If any one of these strings is w, then accept. 
* So every context-free language is decidable by some TM D_A_CFG. We can use CFG_CNF_G to check whether any CFG G accepts some w. But remember that DCFG is less powerful than NCFG.
* A_PDA is decidable. Because we can convert A_PDA to CFG G and then to CFG_CNF_G.
* Note that this constraint on derivation of length (2|w| - 1) is because in each derivation of kind A->BC we can add one extra variable symbol to the derivation string. Each variable symbol of the form B->b can add exactly one terminal symbol in the place of the variable. So in the first (|w|-1) steps we can generate derivation string which contains exactly |w| variables and then in next |w| steps these variables can be replaced by terminals to generate the string of length |w|.


### E_CFG is decidable 



*  The emptiness of CFG is decidable. First mark all the terminals in all derivations. If some derivation has all the symbols marked in the RHS(means these symbols are already shown to be derivable to terminals) then mark that LHS variable in all such derivations. 
* Then again mark RHS of the derivation rules if some of the variable symbols are not marked but the same variable symbol is marked in LHS of the some derivation rule.
* Do this until no new symbol is marked. At the end if the start variable S is marked then the language is not empty. This way we can decide the emptiness of the CFG.


### EQ_CFG is not decidable


*  checking if two CFGs are equivalent is not decidable.


### AMBIG_CFG is not decidable



* Checking whether the same string can be generated by the same grammar by two different parse trees is not decidable.


### A_TM is not decidable 



*  checking whether TM accepts w is not decidable. But A_TM is Turing recognizable. This is because we can’t decide whether TM M will halt or loop forever. We will use the diagonalization method to prove this.
* Side note -  DFA will always stop without looping. But NFA can read empty input string symbols and loop forever but we can decide that because every NFA can be converted to DFA. PDA can read for empty input string symbols, push and pop the stack continuously and loop forever but we can decide A_PDA also by converting it to CFG G. Since DPDA also allows empty input transitions it also can loop forever but that can be converted to always read the input to the end.

One to one - if f(a)=f(b) means a=b. An image in B has a unique preimage in A if it has a preimage.

Onto - every element b in B has some element a in A such that f(a)=b. Every image in B has one preimage in A. Range of f should be equal to the number of elements of B.



### Cantor method 



* Two sets A and B are equal if there is a function that maps two sets with properties one to one and onto(one to one correspondence). Informally we can pair up all their elements. For example natural numbers and integer numbers sets are of equal length in this way of thinking.
* Note that for an uncountably infinite set such as a set of real numbers there is something more than just infinite length in two dimensions. In these cases we can always produce new elements of a set. Even though rational numbers have 2 dimensions of infinite length it is still countable with respect to natural numbers.


### Countably infinite set



* If we can find one to one correspondence with a set of natural numbers then that set is countably infinite. 
* For rational numbers we can list all the numbers in the matrix(This matrix in i’th row will contain the value i in the numerator for all the elements and similarly j’th column will have j as denominator. We will also filter out duplicate elements when we list all the elements of the matrix) 
* Now we can list the elements diagonally and assign a natural number to each of them. Also note that we can’t produce any new rational number that is not in this list. But in the Real number case after listing all the numbers also we can always find some new real numbers.


### Uncountably infinite set 

No of Real number is uncountable (more than number of natural numbers) proof:



* we list all the real numbers and assign natural numbers to it.
* Then we take i’th decimal digit of the real number assigned to i’th natural number and replace it with some random number(we avoid choosing 0 and 9 that may create some approximately equal numbers)to it. like this we can create some new real numbers which are not in the list. So there are more real numbers than natural numbers. 
* Note that we can always add an extra digit at the end whenever we add one new number to the set.
* In computer science each natural number corresponds to one program and each real number corresponds to one problem we need to solve.
* Note this is happening because in the case of natural numbers or rational numbers we can represent all the numbers of those sets as a single dimension. But in the real numbers case we always need two dimensions because real numbers also include irrational numbers which we can’t write in the form (i/j).
* Using current axioms of Mathematics we can’t prove that there is some set which is larger than the set of natural numbers but smaller than the set of real numbers.


### L is uncountable



*  Where L is a set of all the languages. For Example, take a set B of all possible strings of zeros and ones. This set B is countably infinite. Then for each real number create one language. To create a language L1 for a particular real number R first convert the real number into a binary representation BR. Then language L1 will accept string at position i of set B if binary string BR contains 1 at the position i. 
* Here note that we can always extend the set B with larger strings to compare with longer BR. So set L has one to one correspondence with the set of real numbers. This is the reason we say that L is uncountable.


### M is countable 



* Where M is the set of all Turing machines. Here a simple way to understand this is note that TM N can be written as an encoded string. This set of strings is actually a subset of B. We already know that B is countably infinite.


### A_TM is not decidable 



* Checking whether TM accepts w is not decidable. But A_TM is Turing recognizable. We can prove this by proof by contradiction. Assume some TM H decides whether some TM M accepts w. Then we can construct TM D using H and do the opposite of what H outputs. 

We construct program D(&lt;M>) it’s pseudocode is:



*  val =H(&lt;M,&lt;M>>)
*  if val == accept then reject
*  if val == reject then accept

Then execute D(&lt;D>) to get a contradiction. This is like a barber problem where barbers shave everyone who doesn’t shave themselves.


### Halting problem 

We also have recursive proof for this. But here we show an example program.

Assume that the program Halts(input) says whether a program halts or not.

We construct program D(input) it’s pseudocode is:



* val =Halts(input)
* if the val == yes then run forever.
* if val == no then halt.

Now if you feed D as an input to D itself. If Halts(D) says it will halt then D will run forever. If Halts(D) says it will run forever then it will stop. Then there is no such program as Halts(input).


### A_QA is not decidable 

 This is a queue automaton which is equivalent to a Turing machine. So if we A_QA is decidable then A_TM will be decidable


### Complement of A_TM is unrecognisable 



* It can be based on the theorem that A and complement of A is T-recognisable if A is decidable(also complement of A is decidable). For example if  M  and ~M both are T-recognisable, then we can construct decidable M  by doing the following. 
* If M accept then accept, if ~M accept then reject. Here ~M accepts strings that are not in the language of M. Here we will run M and ~M in parallel.
* If A_TM and complement of A_TM both are T-recognisable, then saying that  A_TM would be decidable, which is not true. Also A_TM is recognisable so the complement of A_TM must be unrecognisable.


### Turing Decidability 



* When TM either accepts or rejects all the strings in the language without looping it is called Turing decidable language. This analogy continues for algorithms. We can convert many problems into a set membership problem(here set membership means set of strings that are in a language A). Then we can use the Turing machine to check whether a particular string is in a language. If this language is TM decidable then that problem is decidable. 
* So it is decidable means there is some algorithm which can solve this problem.Halting problems is an example of Turing undecidable. But it is recognisable. Here also we can use the same logic as the Halting problem to prove this. In the halting problem this is happening because of the function description of D. 
* We are checking whether D accepts &lt;D> using D. Inside D we use H to predict that and do the opposite of what H says. So always whatever we H predict about D the D will do the opposite. So there is no such H.
* We can also use the diagonalisation kind of  method to prove this. In that approach rows will be TM and columns will be encodings of TM. Now each position in the matrix will accept if the machine in row accepts encoding of machines in the column. In our definition D accepts &lt;M> if M rejects &lt;M>. So when we reach column D this will create a contradiction. Then in this position we have to accept &lt;D> if D rejects &lt;D> which we can’t because D rejects &lt;D>.


### Turing Recognisable 



* Some languages are not even Turing recognizable. We can prove this using the diagonalization method. Turing machines are countable because they have a finite number of states, transitions, alphabets and tape symbols. So we can represent it with a string of finite length. String of finite lengths are countable regardless of their length. We can prove that using similar logic as rational numbers.
* But there are an uncountable number of languages. We can give one to one correspondence between the set of languages over alphabet sigma and a binary string of infinite length which is an uncountable set. So at the end there are more languages than the number of Turing machines that can recognise them. So some languages are not even Turing recognizable.
* Why the set of languages is uncountable. Because it has two dimensions of infinity. If you see this is infinite in two dimensions. One thing we can say is that there are a finite number of strings of each length in a set of all possible strings. But the second dimension is that we can find an infinite number of combinations of these strings to create different languages. We can prove this using a similar technique as proving a real numbers set is uncountable.
* The language A is decidable if and only if both languages A and complement of A are Turing recognisable.


### Closure of Turing machine



* Closed under Union and Intersection - both Turing decidable and recognisable are closed under union. Both Turing decidable and recognisable are closed under intersection. In both these cases we can run the two decidable or recognisable machines in parallel to decide or recognise the languages.
* Closed under complement- only Turing decidable is closed under complementation. Turing recognisable is not closed under complementation because we can’t say that the machine that is looping will accept or reject.
* Star and concatenation - both T-recognisable and T-decidable languages are closed under concatenation and star operations. For example in concatenation, split the input string w non deterministically into two parts and feed into corresponding machines to decide or recognise the language. Similar analogy we can use for star operation but in star cases there will be a single Turing machine so we can just read the remaining input after accepting part of the input string also.


### Co-Turing recognisable



* A complement of T-recognisable languages is Co-Turing recognisable. If some language A is both T-recognise and its complement is co-T-recognisable then that language is decidable. 
* If you see the venn diagram for these you can understand the closure properties well. For example, in a vague way the union of two T-recognisable languages is always going to be inside the circle of T-recognisable. But complement of T-recognisable language which is not decidable will be in the circle of co-Turing recognisable.



